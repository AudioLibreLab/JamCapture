<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JamCapture</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        /* Custom styles for mobile-first design */
        .status-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .status-idle {
            color: var(--pico-color-success);
        }

        .status-recording {
            color: var(--pico-color-danger);
            animation: pulse 1s infinite;
        }

        /* Recording animation */
        .record-button.recording {
            animation: record-pulse 1.5s infinite;
        }

        @keyframes record-pulse {
            0%, 100% {
                box-shadow:
                    0 4px 8px rgba(0, 0, 0, 0.3),
                    inset 0 2px 4px rgba(255, 255, 255, 0.3),
                    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 0 rgba(255, 68, 68, 0.7);
            }
            50% {
                box-shadow:
                    0 4px 8px rgba(0, 0, 0, 0.3),
                    inset 0 2px 4px rgba(255, 255, 255, 0.3),
                    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 10px rgba(255, 68, 68, 0.2);
            }
        }

        .status-error {
            color: var(--pico-color-warning);
        }

        /* Status message styles */
        .status-message {
            text-align: center;
            margin-top: 0.5rem;
            padding: 0.75rem 1rem;
            border-radius: var(--pico-border-radius);
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status-message.error {
            background-color: var(--pico-color-danger-background);
            border: 1px solid var(--pico-color-danger);
            color: var(--pico-color-danger);
        }

        .status-message.info {
            background-color: var(--pico-color-primary-background);
            border: 1px solid var(--pico-color-primary);
            color: var(--pico-color-primary);
        }

        .status-message.success {
            background-color: var(--pico-color-success-background);
            border: 1px solid var(--pico-color-success);
            color: var(--pico-color-success);
        }

        .status-message.warning {
            background-color: var(--pico-color-warning-background);
            border: 1px solid var(--pico-color-warning);
            color: var(--pico-color-warning);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .control-section {
            margin-bottom: 2rem;
        }

        .big-button {
            font-size: 1.25rem;
            padding: 1rem 2rem;
            min-height: 60px;
            touch-action: manipulation;
        }

        /* Funky recording control */
        .recording-control {
            display: flex;
            justify-content: center;
            margin: 2rem 0;
        }

        .funky-button {
            position: relative;
            width: 140px;
            height: 140px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow:
                0 8px 25px rgba(0, 0, 0, 0.4),
                0 4px 10px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        /* Disabled state for button */
        .funky-button:disabled {
            cursor: not-allowed;
            opacity: 0.7;
            transform: scale(0.98);
        }

        /* Record state - glowing red */
        .funky-record {
            background: radial-gradient(circle at 30% 30%, #ff4757, #ff3838, #c44569);
            color: white;
            border: 4px solid #ff6b7a;
            animation: record-glow 2s infinite alternate;
        }

        .funky-record:hover {
            transform: scale(1.05);
            box-shadow:
                0 12px 35px rgba(255, 71, 87, 0.4),
                0 6px 15px rgba(255, 71, 87, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }

        /* Stop state - funky green square with rounded corners */
        .funky-stop {
            background: linear-gradient(145deg, #2ed573, #20bf6b, #26de81);
            color: white;
            border: 4px solid #7bed9f;
            border-radius: 25px;
            animation: stop-pulse 1.5s infinite;
            box-shadow:
                0 8px 25px rgba(46, 213, 115, 0.4),
                0 4px 10px rgba(46, 213, 115, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }

        .funky-stop:hover {
            transform: scale(1.05) rotate(-2deg);
            box-shadow:
                0 15px 40px rgba(46, 213, 115, 0.6),
                0 8px 20px rgba(46, 213, 115, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
            background: linear-gradient(145deg, #26de81, #2ed573, #20bf6b);
        }

        /* Wait state - pulsing orange for loading/connecting */
        .funky-wait {
            background: linear-gradient(145deg, #ffa726, #ff9800, #f57c00);
            color: white;
            border: 4px solid #ffcc02;
            border-radius: 50%;
            animation: wait-spin 2s linear infinite;
            cursor: wait;
        }

        .funky-wait:hover {
            transform: scale(1.02);
            box-shadow:
                0 12px 35px rgba(255, 152, 0, 0.4),
                0 6px 15px rgba(255, 152, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }

        .button-icon {
            font-size: 2.5rem;
            line-height: 1;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }

        .button-text {
            font-size: 1.1rem;
            font-weight: 900;
            letter-spacing: 1px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .button-pulse {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            opacity: 0;
            pointer-events: none;
        }

        .funky-record .button-pulse {
            animation: pulse-ring 2s infinite;
        }

        /* Animations */
        @keyframes record-glow {
            0% {
                box-shadow:
                    0 8px 25px rgba(255, 71, 87, 0.3),
                    0 4px 10px rgba(255, 71, 87, 0.2),
                    inset 0 2px 4px rgba(255, 255, 255, 0.1);
            }
            100% {
                box-shadow:
                    0 12px 35px rgba(255, 71, 87, 0.5),
                    0 6px 15px rgba(255, 71, 87, 0.4),
                    inset 0 2px 4px rgba(255, 255, 255, 0.2);
            }
        }

        @keyframes stop-pulse {
            0%, 100% {
                transform: scale(1) rotate(0deg);
                box-shadow:
                    0 8px 25px rgba(46, 213, 115, 0.4),
                    0 4px 10px rgba(46, 213, 115, 0.3);
            }
            50% {
                transform: scale(1.03) rotate(1deg);
                box-shadow:
                    0 12px 35px rgba(46, 213, 115, 0.6),
                    0 6px 15px rgba(46, 213, 115, 0.5);
            }
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.4;
            }
            100% {
                transform: scale(1.2);
                opacity: 0;
            }
        }

        @keyframes wait-spin {
            0% {
                transform: rotate(0deg);
                box-shadow:
                    0 8px 25px rgba(255, 152, 0, 0.3),
                    0 4px 10px rgba(255, 152, 0, 0.2);
            }
            50% {
                box-shadow:
                    0 12px 35px rgba(255, 152, 0, 0.5),
                    0 6px 15px rgba(255, 152, 0, 0.4);
            }
            100% {
                transform: rotate(360deg);
                box-shadow:
                    0 8px 25px rgba(255, 152, 0, 0.3),
                    0 4px 10px rgba(255, 152, 0, 0.2);
            }
        }

        /* Button states during transitions */
        .funky-button:active {
            transform: scale(0.95);
        }

        .recording-info {
            background-color: var(--pico-background-color);
            border: 1px solid var(--pico-border-color);
            border-radius: var(--pico-border-radius);
            padding: 1rem;
            margin-top: 1rem;
        }

        .config-info {
            background-color: var(--pico-card-background-color);
            border-radius: var(--pico-border-radius);
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .channel-list {
            margin: 0.5rem 0;
        }

        .channel-item {
            padding: 0.25rem 0;
            font-family: var(--pico-font-family-monospace);
            font-size: 0.8rem;
        }

        .inheritance-inherited {
            color: var(--pico-color-success);
        }

        .inheritance-profile {
            color: var(--pico-color-primary);
        }

        /* Audio Player Styles */
        .audio-player-section {
            background-color: var(--pico-card-background-color);
            border-radius: var(--pico-border-radius);
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid var(--pico-border-color);
        }

        .player-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }


        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-custom {
            display: none;
        }

        .file-input-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background-color: var(--pico-color-secondary);
            color: white;
            border: none;
            border-radius: var(--pico-border-radius);
            cursor: pointer;
            transition: background-color 0.3s ease;
            width: 100%;
            justify-content: center;
        }

        .file-input-button:hover {
            background-color: var(--pico-color-secondary-hover);
        }

        .file-input-button:disabled {
            background-color: var(--pico-color-secondary-background);
            color: var(--pico-muted-color);
            cursor: not-allowed;
        }

        .audio-player-container {
            margin-top: 1rem;
        }

        .custom-audio-player {
            width: 100%;
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-background-color);
            outline: none;
        }

        .file-info {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: var(--pico-background-color);
            border-radius: var(--pico-border-radius);
            font-size: 0.9rem;
            color: var(--pico-muted-color);
        }

        .player-status {
            text-align: center;
            padding: 1rem;
            color: var(--pico-muted-color);
            font-style: italic;
        }

        /* Audio Player Tabs */
        .audio-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1rem;
            border-radius: var(--pico-border-radius);
            overflow: hidden;
            border: 1px solid var(--pico-border-color);
        }

        .audio-tab {
            flex: 1;
            padding: 0.75rem 1rem;
            background-color: var(--pico-background-color);
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--pico-muted-color);
            border-right: 1px solid var(--pico-border-color);
        }

        .audio-tab:last-child {
            border-right: none;
        }

        .audio-tab:hover {
            background-color: var(--pico-color-primary-background);
            color: var(--pico-color-primary);
        }

        .audio-tab.active {
            background-color: var(--pico-color-primary);
            color: white;
            font-weight: 600;
        }

        .audio-tab-icon {
            font-size: 1.1em;
        }

        /* Source status styles */
        .source-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-card-background-color);
            font-family: var(--pico-font-family-monospace);
            font-size: 0.85rem;
        }

        .source-name {
            font-weight: bold;
            flex-grow: 1;
        }

        .source-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
        }

        .source-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .source-available {
            background-color: var(--pico-color-success);
        }

        .source-unavailable {
            background-color: var(--pico-color-danger);
        }

        .source-duplicate {
            background-color: var(--pico-color-warning);
        }

        .source-unknown {
            background-color: var(--pico-color-warning);
        }

        .source-port {
            color: var(--pico-muted-color);
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        /* Hide sections conditionally */
        .hidden {
            display: none;
        }

        /* Navigation header */
        .nav-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 1rem 0;
            margin-bottom: 2rem;
            border-radius: var(--pico-border-radius);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .nav-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .nav-title {
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            text-decoration: none;
            margin: 0;
        }

        .nav-links {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: var(--pico-border-radius);
            transition: background-color 0.3s ease;
        }

        .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .nav-link.active {
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* Profile display */
        .profile-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .profile-field {
            flex: 1;
            background-color: var(--pico-background-color);
            border: 1px solid var(--pico-border-color);
            color: var(--pico-color);
            cursor: not-allowed;
        }

        .change-profile-btn {
            white-space: nowrap;
        }

        /* All Recordings Styles */
        .recordings-controls {
            margin-bottom: 1rem;
        }

        .search-sort-bar {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .recordings-search-input {
            flex: 1;
            min-width: 200px;
            padding: 0.5rem;
            border: 1px solid var(--pico-border-color);
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-background-color);
        }

        .recordings-sort-select {
            padding: 0.5rem;
            border: 1px solid var(--pico-border-color);
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-background-color);
            min-width: 150px;
        }

        .recordings-list-container {
            background-color: var(--pico-background-color);
            border-radius: var(--pico-border-radius);
            border: 1px solid var(--pico-border-color);
            overflow: hidden;
        }

        .recordings-status {
            text-align: center;
            padding: 1rem;
            color: var(--pico-muted-color);
            font-style: italic;
        }

        .recordings-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .recording-item {
            display: grid;
            grid-template-columns: 1fr auto auto auto auto auto;
            gap: 0.5rem;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--pico-border-color);
            transition: background-color 0.3s ease;
        }

        .recording-item:hover {
            background-color: var(--pico-color-primary-background);
        }

        .recording-item:last-child {
            border-bottom: none;
        }

        .recording-name {
            font-weight: 500;
            color: var(--pico-color-primary);
            word-break: break-word;
            font-size: 0.9rem;
        }

        .recording-size {
            color: var(--pico-muted-color);
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .recording-date {
            color: var(--pico-muted-color);
            font-size: 0.8rem;
            white-space: nowrap;
        }
        .recording-format {
            color: var(--pico-muted-color);
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .recording-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: var(--pico-border-radius);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 2rem;
            height: 2rem;
        }

        .recording-btn.play {
            background-color: var(--pico-color-success);
            color: white;
        }

        .recording-btn.play:hover {
            background-color: var(--pico-color-success-hover);
        }

        .recording-btn.backing {
            background-color: var(--pico-color-primary);
            color: white;
        }

        .recording-btn.backing:hover {
            background-color: var(--pico-color-primary-hover);
        }

        .recording-btn.download {
            background-color: var(--pico-color-secondary);
            color: white;
        }

        .recording-btn.download:hover {
            background-color: var(--pico-color-secondary-hover);
        }

        /* Backing track styles */
        .selected-backingtrack {
            background-color: var(--pico-color-yellow-background) !important;
            border-left: 4px solid var(--pico-color-yellow);
        }

        .selected-badge {
            background-color: var(--pico-color-yellow);
            color: var(--pico-color-yellow-inverse);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .action-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: var(--pico-border-radius);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .action-btn.play-btn {
            background-color: var(--pico-color-success);
            color: white;
        }

        .action-btn.play-btn:hover {
            background-color: var(--pico-color-success-hover);
        }


        .action-btn.download-btn {
            background-color: var(--pico-color-secondary);
            color: white;
        }

        .action-btn.download-btn:hover {
            background-color: var(--pico-color-secondary-hover);
        }

        /* Recording info layout for backing tracks */
        .recording-info {
            display: flex;
            flex-direction: column;
            flex: 1;
            gap: 0.25rem;
        }

        .recording-meta {
            color: var(--pico-muted-color);
            font-size: 0.8rem;
        }

        .recording-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .recordings-pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background-color: var(--pico-card-background-color);
            border-top: 1px solid var(--pico-border-color);
            flex-wrap: wrap;
            gap: 1rem;
        }

        .pagination-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            font-size: 0.9rem;
            color: var(--pico-muted-color);
        }

        .pagination-controls {
            display: flex;
            gap: 0.5rem;
        }

        .pagination-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--pico-border-color);
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-background-color);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .pagination-btn:hover:not(:disabled) {
            background-color: var(--pico-color-primary-background);
            border-color: var(--pico-color-primary);
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .big-button {
                width: 100%;
                margin-bottom: 1rem;
            }

            h1 {
                font-size: 2rem;
            }

            /* All Recordings mobile styles */
            .search-sort-bar {
                flex-direction: column;
                gap: 0.5rem;
            }

            .recordings-search-input {
                min-width: unset;
                width: 100%;
            }

            .recordings-sort-select {
                width: 100%;
                min-width: unset;
            }

            .recording-item {
                grid-template-columns: 1fr;
                gap: 0.5rem;
                padding: 1rem;
            }

            .recording-name {
                margin-bottom: 0.5rem;
                font-size: 1rem;
            }

            .recordings-pagination {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }

            .pagination-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body hx-ext="json-enc">
    <!-- Navigation Header -->
    <div class="nav-header">
        <div class="nav-content">
            <a href="/" class="nav-title">üé∏ JamCapture</a>
            <div class="nav-links">
                <a href="/" class="nav-link active">üè† Recording</a>
                <a href="/config" class="nav-link">‚öôÔ∏è Configuration</a>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Status Header -->
        <div class="status-header">
            <h2 id="status-display" class="status-idle">IDLE</h2>
            <div id="status-message" class="status-message hidden"></div>
        </div>

        <!-- Funky Recording Control -->
        <div class="recording-control">
            <button type="button" id="main-control-button" class="funky-button funky-record" onclick="toggleRecording()">
                <div class="button-icon">üî¥</div>
                <div class="button-text">REC</div>
                <div class="button-pulse"></div>
            </button>
        </div>

        <!-- Configuration Form (hidden during recording) -->
        <div class="control-section" id="config-form">
            <form id="record-form" hx-post="/record" hx-target="#response-area" hx-swap="innerHTML">
                <label for="profile">Active Profile:</label>
                <div class="profile-display">
                    <input type="text" id="profile" name="profile" readonly class="profile-field" value="Loading...">
                    <button type="button" class="change-profile-btn" onclick="window.location.href='/config'">Change Profile</button>
                </div>

                <label for="song">Song Name:</label>
                <input type="text" id="song" name="song" placeholder="Enter song name" required>
            </form>
        </div>

        <!-- Recording Info (shown during recording) -->
        <div id="recording-info" class="recording-info hidden">
            <h3>üìπ Recording Session</h3>
            <div id="session-details">
                <!-- Session info populated by HTMX -->
            </div>
        </div>

        <!-- Response Area for user feedback -->
        <div id="response-area"></div>

        <!-- Audio Player Section -->
        <div class="audio-player-section">
            <h3>üéß Audio Player</h3>

            <div class="player-controls">
                <!-- Audio Source Tabs -->
                <div class="audio-tabs">
                    <button class="audio-tab" id="tab-backingtracks" onclick="selectAudioSource('backingtracks')">
                        <span class="audio-tab-icon">üéµ</span>
                        <span>Backingtracks</span>
                    </button>
                    <button class="audio-tab active" id="tab-latest" onclick="selectAudioSource('latest')">
                        <span class="audio-tab-icon">üé§</span>
                        <span>Last Recording</span>
                    </button>
                    <button class="audio-tab" id="tab-all" onclick="selectAudioSource('all')">
                        <span class="audio-tab-icon">üìÅ</span>
                        <span>All Recordings</span>
                    </button>
                </div>

                <!-- Audio Player Container -->
                <div class="audio-player-container">
                    <div id="player-status" class="player-status">
                        Loading last recording...
                    </div>
                    <audio id="audio-player" class="custom-audio-player hidden" controls preload="metadata">
                        Your browser does not support the audio element.
                    </audio>
                    <div id="audio-error" class="hidden" style="color: var(--pico-color-danger); margin-top: 0.5rem; font-size: 0.9rem;"></div>
                    <div id="file-info" class="file-info hidden"></div>
                </div>

                <!-- Backingtracks Controls -->
                <div id="backingtracks-controls" class="hidden">
                    <div class="recordings-controls">
                        <div class="search-sort-bar">
                            <input type="text" id="backingtracks-search" placeholder="üîç Search backing tracks..." class="recordings-search-input">
                            <select id="backingtracks-sort" class="recordings-sort-select">
                                <option value="date_desc">üìÖ Newest first</option>
                                <option value="date_asc">üìÖ Oldest first</option>
                                <option value="name_asc">üî§ Name A‚ÜíZ</option>
                                <option value="name_desc">üî§ Name Z‚ÜíA</option>
                            </select>
                        </div>
                    </div>

                    <div class="recordings-list-container">
                        <div id="backingtracks-status" class="recordings-status">
                            Loading backing tracks...
                        </div>
                        <div id="backingtracks-list" class="recordings-list hidden">
                            <!-- Backing tracks will be populated by JavaScript -->
                        </div>
                        <div id="backingtracks-pagination" class="recordings-pagination hidden">
                            <div class="pagination-info">
                                <span id="backingtracks-pagination-info">Page 1 of 1</span>
                                <span id="backingtracks-total-info">(0 backing tracks)</span>
                            </div>
                            <div class="pagination-controls">
                                <button id="backingtracks-prev" class="pagination-btn" onclick="previousBackingtracksPage()" disabled>‚Äπ Previous</button>
                                <button id="backingtracks-next" class="pagination-btn" onclick="nextBackingtracksPage()" disabled>Next ‚Ä∫</button>
                            </div>
                        </div>
                    </div>

                    <!-- File Upload for New Backing Tracks -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--pico-border-color);">
                        <h4 style="margin-bottom: 0.5rem;">Upload New Backing Track</h4>
                        <div class="file-input-wrapper">
                            <input type="file" id="audio-file-input" class="file-input-custom" accept="audio/*" onchange="loadLocalFile(this)">
                            <button type="button" class="file-input-button" onclick="document.getElementById('audio-file-input').click()">
                                <span>üìÇ</span>
                                <span>Choose Audio File</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- All Recordings Controls -->
                <div id="all-recordings-controls" class="hidden">
                    <div class="recordings-controls">
                        <div class="search-sort-bar">
                            <input type="text" id="recordings-search" placeholder="üîç Search recordings..." class="recordings-search-input">
                            <select id="recordings-sort" class="recordings-sort-select">
                                <option value="date_desc">üìÖ Newest first</option>
                                <option value="date_asc">üìÖ Oldest first</option>
                                <option value="name_asc">üî§ Name A‚ÜíZ</option>
                                <option value="name_desc">üî§ Name Z‚ÜíA</option>
                            </select>
                        </div>
                    </div>

                    <div class="recordings-list-container">
                        <div id="recordings-status" class="recordings-status">
                            Loading recordings...
                        </div>
                        <div id="recordings-list" class="recordings-list hidden">
                            <!-- Recordings will be populated by JavaScript -->
                        </div>
                        <div id="recordings-pagination" class="recordings-pagination hidden">
                            <div class="pagination-info">
                                <span id="pagination-info-text">Page 1 of 1</span>
                                <span id="pagination-total-text">(0 recordings)</span>
                            </div>
                            <div class="pagination-controls">
                                <button id="pagination-prev" class="pagination-btn" onclick="previousRecordingsPage()" disabled>‚Äπ Previous</button>
                                <button id="pagination-next" class="pagination-btn" onclick="nextRecordingsPage()" disabled>Next ‚Ä∫</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sources Status -->
        <div class="config-info">
            <details id="sources-section">
                <summary>üîå Audio Sources Status</summary>
                <div id="sources-details">
                    <p>Loading sources...</p>
                </div>
            </details>
        </div>

        <!-- Configuration Info -->
        <div class="config-info">
            <details>
                <summary>üìã Configuration Details</summary>
                <div id="config-details">
                    <p>Loading configuration...</p>
                </div>
            </details>
        </div>

    </div>

    <script>
        // Global state
        let currentProfile = 'default';
        let pollingInterval;

        // All Recordings state
        let allRecordings = [];
        let filteredRecordings = [];
        let currentSort = 'date_desc';
        let searchQuery = '';
        let currentPage = 1;
        const ITEMS_PER_PAGE = 10;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadActiveProfile();
            startStatusPolling();
            initializeAudioPlayer();

            // Note: Latest Recording loading is now handled by initializeAudioPlayer()
            // to avoid conflicts with backing track initialization
        });

        // Load active profile
        function loadActiveProfile() {
            fetch('/config/active')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const newProfile = data.active_profile || 'default';
                        const profileField = document.getElementById('profile');
                        profileField.value = newProfile;

                        // Check if profile changed
                        if (currentProfile !== newProfile) {
                            const oldProfile = currentProfile;
                            currentProfile = newProfile;

                            if (oldProfile !== 'default') {  // Don't show message on initial load
                                console.log(`Profile changed from ${oldProfile} to ${currentProfile}`);

                                // Refresh sources and config immediately when profile changes
                                updateSourcesInfo();
                                updateStatus();  // This will update the config info

                                // Show brief notification
                                const responseArea = document.getElementById('response-area');
                                responseArea.innerHTML = `
                                    <article style="background-color: var(--pico-color-success-background);">
                                        <p>‚úÖ Profile changed to <strong>${currentProfile}</strong> - sources updated</p>
                                    </article>
                                `;

                                // Clear notification after 3 seconds
                                setTimeout(() => {
                                    responseArea.innerHTML = '';
                                }, 3000);
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Failed to load active profile:', error);
                    document.getElementById('profile').value = 'Error loading profile';
                });
        }

        // Start polling for status updates
        function startStatusPolling() {
            updateStatus(); // Initial load
            updateSourcesInfo(); // Initial sources load

            pollingInterval = setInterval(() => {
            updateStatus();
            updateSourcesInfo();
            }, 2000); // Poll every 2 seconds
        }


        // Fast polling during connection attempts
        let fastPollingInterval = null;

        function startFastPolling() {
            if (fastPollingInterval) {
                clearInterval(fastPollingInterval);
            }
            fastPollingInterval = setInterval(updateStatus, 500); // Poll every 500ms

            // Stop fast polling after 15 seconds
            setTimeout(() => {
                if (fastPollingInterval) {
                    clearInterval(fastPollingInterval);
                    fastPollingInterval = null;
                }
            }, 15000);
        }

        // Update status and UI state
        function updateStatus() {
            fetch('/status')
                .then(response => response.json())
                .then(data => {
                    updateStatusDisplay(data.status, data.message);
                    updateSessionInfo(data.session);

                    // Update configuration info
                    updateConfigInfo(data.resolved_config);

                    // Update UI state based on status
                    toggleUIState(data.status);

                    // Sources status updated separately via startSourcesPolling()
                })
                .catch(error => {
                    console.error('Failed to update status:', error);
                    updateStatusDisplay('ERROR', 'Failed to communicate with server');
                });
        }

        // Update status display
        function updateStatusDisplay(status, message) {
            const statusDisplay = document.getElementById('status-display');
            statusDisplay.textContent = status;

            // Update CSS classes
            statusDisplay.className = '';
            statusDisplay.classList.add('status-' + status.toLowerCase());

            // Handle status message
            const statusMessage = document.getElementById('status-message');
            if (message && message.trim() !== '') {
                statusMessage.textContent = message;
                statusMessage.classList.remove('hidden');

                // Apply appropriate styling based on status
                statusMessage.className = 'status-message';
                switch (status.toLowerCase()) {
                    case 'error':
                        statusMessage.classList.add('error');
                        break;
                    case 'ready':
                        statusMessage.classList.add('info');
                        break;
                    case 'recording':
                        statusMessage.classList.add('success');
                        break;
                    default:
                        statusMessage.classList.add('info');
                        break;
                }
            } else {
                statusMessage.classList.add('hidden');
                statusMessage.textContent = '';
            }
        }

        // Update session information
        function updateSessionInfo(session) {
            const sessionDetails = document.getElementById('session-details');
            if (session) {
                const startTime = new Date(session.start_time).toLocaleTimeString();
                sessionDetails.innerHTML = `
                    <p><strong>Song:</strong> ${session.song_name}</p>
                    <p><strong>Started:</strong> ${startTime}</p>
                    <p><strong>Channels:</strong> ${session.channel_count}</p>
                    <p><strong>Output:</strong> ${session.output_file}</p>
                `;
            } else {
                sessionDetails.innerHTML = '<p>No active session</p>';
            }
        }

        // Update configuration information
        function updateConfigInfo(config) {
            if (!config) return;

            const configDetails = document.getElementById('config-details');

            let channelsHtml = '<div class="channel-list">';
            config.channels.forEach(channel => {
                const sources = Array.isArray(channel.sources) ? channel.sources.join(', ') : (channel.sources || 'undefined');

                channelsHtml += `
                    <div class="channel-item" style="border: 1px solid var(--pico-border-color); border-radius: var(--pico-border-radius); padding: 0.75rem; margin: 0.5rem 0; background: var(--pico-card-background-color);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <strong>${channel.name}</strong>
                                <span class="port-type ${channel.type}" style="background: ${channel.type === 'input' ? 'var(--pico-color-primary)' : 'var(--pico-color-secondary)'}; color: white; padding: 0.2rem 0.5rem; border-radius: 3px; font-size: 0.7rem;">${channel.type.toUpperCase()}</span>
                            </div>
                        </div>
                        <div style="font-size: 0.8rem; color: var(--pico-muted-color); font-family: monospace; margin-bottom: 0.5rem; word-break: break-all;">${sources}</div>
                        <div style="display: flex; gap: 1rem; font-size: 0.85rem;">
                            <div><strong>Volume:</strong> ${channel.volume}x</div>
                            <div><strong>Delay:</strong> ${channel.delay}ms</div>
                        </div>
                    </div>
                `;
            });
            channelsHtml += '</div>';

            configDetails.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="margin-bottom: 0.75rem;">üé§ Audio Channels</h4>
                    ${channelsHtml}
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <h4 style="margin-bottom: 0.75rem;">üìÅ Output Settings</h4>
                    <div style="background: var(--pico-card-background-color); padding: 0.75rem; border-radius: var(--pico-border-radius); border: 1px solid var(--pico-border-color);">
                        <div style="margin-bottom: 0.5rem;"><strong>Directory:</strong> <code style="word-break: break-all;">${config.output_dir}</code></div>
                        <div style="margin-bottom: 0.5rem;"><strong>Format:</strong> ${config.format}</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Sample Rate:</strong> ${config.sample_rate} Hz</div>
                        <div><strong>Auto Mix:</strong> <span style="color: ${config.auto_mix ? 'var(--pico-color-success)' : 'var(--pico-color-warning)'};">${config.auto_mix ? '‚úÖ Enabled' : '‚ùå Disabled'}</span></div>
                    </div>
                </div>

            `;
        }


        /**
         * Updates the sources UI by fetching data from the server.
         * Safety: It first checks the system status to avoid restarting
         * audio sessions during an active recording.
         */
        async function updateSourcesInfo() {
            try {
                // 1. Check current system status first
                const statusResponse = await fetch('/status');
                const statusData = await statusResponse.json();

                // 3. Safe to proceed: Fetch hardware sources
                const sourcesResponse = await fetch('/sources');
                const data = await sourcesResponse.json();

                const sourcesDetails = document.getElementById('sources-details');

                if (!data.sources || data.sources.length === 0) {
                    sourcesDetails.innerHTML = '<p>No sources configured</p>';
                    return;
                }

                // 4. Build the HTML for the sources list
                let sourcesHtml = '';
                data.sources.forEach(source => {
                    const statusClass = `source-${source.status}`;
                    const statusEmoji = source.status === 'available' ? '‚úÖ' :
                                    source.status === 'unavailable' ? '‚ùå' :
                                    source.status === 'duplicate' ? '‚ö†Ô∏è' : '‚ùì';
                    const typeEmoji = source.type === 'input' ? 'üé§' : 'üîä';

                    sourcesHtml += `
                        <div class="source-item">
                            <div>
                                <div class="source-name">${typeEmoji} ${source.name}</div>
                                <div class="source-port">${source.source}</div>
                            </div>
                            <div class="source-status">
                                <span class="source-indicator ${statusClass}"></span>
                                <span>${statusEmoji} ${source.status.toUpperCase()}</span>
                            </div>
                        </div>`;
                });

                sourcesDetails.innerHTML = sourcesHtml;

                // 5. Auto-expand the UI section if hardware is missing or duplicates detected while in READY state
                if (statusData.status === 'READY') {
                    const hasUnavailable = data.sources.some(s => s.status === 'unavailable');
                    const hasDuplicates = data.sources.some(s => s.status === 'duplicate');
                    if (hasUnavailable || hasDuplicates) {
                        const section = document.getElementById('sources-section');
                        if (section) section.open = true;
                    }
                }

            } catch (error) {
                console.error('Failed to update sources:', error);
                const details = document.getElementById('sources-details');
                if (details) {
                    details.innerHTML = '<p style="color: var(--pico-color-danger);">Error loading sources</p>';
                }
            }
        }


        // Toggle recording function
        function toggleRecording() {
            // Get current status from server
            fetch('/status')
                .then(response => response.json())
                .then(data => {
                    const status = data.status;

                    if (status === 'RECORDING') {
                        stopRecording();
                    } else if (status === 'READY') {
                        cancelReady();
                    } else if (status === 'STANDBY') {
                        if (validateFormBeforeStart()) {
                            startReady();
                        }
                    }
                })
                .catch(error => {
                    console.error('Failed to get status:', error);
                });
        }

        // Validation function (separate from startRecording)
        function validateFormBeforeStart() {
            const songInput = document.getElementById('song');

            if (!songInput.value.trim()) {
                alert('Please enter a song name');
                songInput.focus();
                return false;
            }

            return true;
        }

        // Start ready state (STANDBY -> READY)
        function startReady() {
            const profileField = document.getElementById('profile');
            const songInput = document.getElementById('song');

            // First validate that the profile still exists and hasn't changed
            fetch('/config/active')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Profile has been deleted in another session');
                    }
                    return response.json();
                })
                .then(profileData => {
                    if (!profileData.success) {
                        throw new Error('Profile has been deleted in another session');
                    }

                    const serverProfile = profileData.active_profile || 'default';
                    if (currentProfile !== serverProfile) {
                        throw new Error(`Active profile has been changed to '${serverProfile}' in another session`);
                    }

                    // Profile is valid - first lock it, then proceed with ready request
                    return fetch('/config/lock', {
                        method: 'POST'
                    })
                    .then(response => response.json())
                    .then(lockData => {
                        if (!lockData.success) {
                            throw new Error(lockData.error);
                        }

                        // Profile locked successfully - proceed with ready request
                        const formData = new URLSearchParams();
                        formData.append('profile', profileField.value === 'default' ? '' : profileField.value);
                        formData.append('song', songInput.value.trim());
                        // Auto mix is now configured in the YAML, no longer a form parameter

                        // Send request to ready endpoint
                        return fetch('/ready', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: formData
                        });
                    });
                })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const responseArea = document.getElementById('response-area');
                    responseArea.innerHTML = `
                        <article style="background-color: var(--pico-color-success-background);">
                            <h4>‚è≥ Waiting for Audio Sources</h4>
                            <p><strong>Please start playing audio in Chrome</strong><br>
                            Recording will start automatically when all sources are detected.</p>
                        </article>
                    `;

                    // Start fast polling for status updates
                    startFastPolling();

                } else {
                    throw new Error(data.error || 'Failed to start ready');
                }
            })
            .catch(error => {
                const responseArea = document.getElementById('response-area');

                // Check if it's a profile-related error
                const isProfileError = error.message && (
                    error.message.includes('Profile has been deleted') ||
                    error.message.includes('Active profile has been changed')
                );

                const errorTitle = isProfileError ? 'üîÑ Profile Configuration Error' : '‚ùå Error';
                const errorAction = isProfileError ? '<p><small>Please refresh the page to reload the current profile configuration.</small></p>' : '';

                responseArea.innerHTML = `
                    <article style="background-color: var(--pico-color-danger-background);">
                        <h4>${errorTitle}</h4>
                        <p>${error.message}</p>
                        ${errorAction}
                    </article>
                `;
            });
        }

        // Cancel ready state (READY -> STANDBY)
        function cancelReady() {
            fetch('/cancel', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Unlock the profile after successful cancel
                    return fetch('/config/unlock', {
                        method: 'POST'
                    })
                    .then(() => {
                        const responseArea = document.getElementById('response-area');
                        responseArea.innerHTML = `
                            <article style="background-color: var(--pico-color-success-background);">
                                <h4>‚úÖ Cancelled</h4>
                                <p>${data.message}</p>
                            </article>
                        `;

                        // Clear message after 3 seconds
                        setTimeout(() => {
                            responseArea.innerHTML = '';
                        }, 3000);
                    });
                } else {
                    throw new Error(data.error || 'Cancel failed');
                }
            })
            .catch(error => {
                const responseArea = document.getElementById('response-area');
                responseArea.innerHTML = `
                    <article style="background-color: var(--pico-color-danger-background);">
                        <h4>‚ùå Error</h4>
                        <p>${error.message}</p>
                    </article>
                `;
            });
        }

        // Stop recording function
        function stopRecording() {
            fetch('/stop', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Always refresh "Last Recording" immediately after successful stop to update the song name
                    console.log('Refreshing last recording after successful stop');

                    // Check if "Last Recording" is currently selected to update the player
                    const latestTab = document.getElementById('tab-latest');
                    if (latestTab && latestTab.classList.contains('active')) {
                        // User is viewing Last Recording - update the player immediately
                        loadLatestRecording();
                    } else {
                        // User is viewing Backingtrack but we still need to update the last recording data
                        // for when they switch back to it - do a silent refresh
                        fetch('/api/latest-recording')
                            .then(response => {
                                if (response.ok) {
                                    console.log('Last recording data refreshed in background');
                                }
                            })
                            .catch(error => {
                                console.warn('Background refresh of last recording failed:', error);
                            });
                    }

                    // Unlock the profile after successful stop
                    return fetch('/config/unlock', {
                        method: 'POST'
                    })
                    .then(() => {
                        const responseArea = document.getElementById('response-area');
                        responseArea.innerHTML = `
                            <article style="background-color: var(--pico-color-success-background);">
                                <h4>‚úÖ Success</h4>
                                <p>${data.message}</p>
                            </article>
                        `;

                        // Clear success message after 3 seconds
                        setTimeout(() => {
                            responseArea.innerHTML = '';
                        }, 3000);

                    });
                } else {
                    const responseArea = document.getElementById('response-area');
                    responseArea.innerHTML = `
                        <article style="background-color: var(--pico-color-danger-background);">
                            <h4>‚ùå Error</h4>
                            <p>${data.error}</p>
                        </article>
                    `;
                }
            })
            .catch(error => {
                const responseArea = document.getElementById('response-area');
                responseArea.innerHTML = `
                    <article style="background-color: var(--pico-color-danger-background);">
                        <h4>‚ùå Error</h4>
                        <p>${error.message}</p>
                    </article>
                `;
            });
        }

        // Update button appearance based on server status
        function updateButtonState(status) {
            const button = document.getElementById('main-control-button');
            const icon = button.querySelector('.button-icon');
            const text = button.querySelector('.button-text');

            switch (status) {
                case 'READY':
                    button.className = 'funky-button funky-wait';
                    icon.textContent = '‚è≥';
                    text.textContent = 'CANCEL';
                    break;
                case 'RECORDING':
                    button.className = 'funky-button funky-stop';
                    icon.textContent = '‚èπÔ∏è';
                    text.textContent = 'STOP';
                    break;
                case 'STANDBY':
                default:
                    button.className = 'funky-button funky-record';
                    icon.textContent = 'üî¥';
                    text.textContent = 'REC';
                    break;
            }
        }

        // Toggle UI state based on recording status
        function toggleUIState(status) {
            const configForm = document.getElementById('config-form');
            const recordingInfo = document.getElementById('recording-info');
            const responseArea = document.getElementById('response-area');

            // Update button state based on server status
            updateButtonState(status);

            if (status === 'RECORDING') {
                configForm.classList.add('hidden');
                recordingInfo.classList.remove('hidden');

                // Clear any waiting message when recording starts
                responseArea.innerHTML = '';

            } else {
                configForm.classList.remove('hidden');
                recordingInfo.classList.add('hidden');

                // Clear waiting message when returning to STANDBY
                if (status === 'STANDBY') {
                    responseArea.innerHTML = '';
                }
            }
        }

        // HTMX event handlers for success/error responses
        document.body.addEventListener('htmx:responseError', function(event) {
            const responseArea = document.getElementById('response-area');
            responseArea.innerHTML = `
                <article style="background-color: var(--pico-color-danger-background);">
                    <h4>‚ùå Error</h4>
                    <p>${event.detail.xhr.responseText || 'An error occurred'}</p>
                </article>
            `;
        });

        document.body.addEventListener('htmx:afterRequest', function(event) {
            if (event.detail.successful) {
                // Immediately update status after successful action
                setTimeout(updateStatus, 500);
            }
        });

        // Handle successful responses
        document.body.addEventListener('htmx:beforeSwap', function(event) {
            if (event.detail.xhr.status === 200) {
                try {
                    const response = JSON.parse(event.detail.xhr.responseText);
                    if (response.success) {
                        const responseArea = document.getElementById('response-area');
                        responseArea.innerHTML = `
                            <article style="background-color: var(--pico-color-success-background);">
                                <h4>‚úÖ Success</h4>
                                <p>${response.message}</p>
                            </article>
                        `;

                        // Clear success message after 3 seconds
                        setTimeout(() => {
                            responseArea.innerHTML = '';
                        }, 3000);

                        event.detail.shouldSwap = false; // Prevent default swap
                    }
                } catch (e) {
                    // Not JSON, let HTMX handle normally
                }
            }
        });

        // ===== AUDIO PLAYER FUNCTIONS =====

        // Initialize audio player
        function initializeAudioPlayer() {
            // Check if there's a selected backing track
            fetch('/api/backingtracks/selected')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.selected_backingtrack) {
                        updatePlayerStatus(`üéµ Your selected backing track (${data.selected_backingtrack.name}) is available`);
                        // Auto-select backing tracks source if we have a selected backing track
                        selectAudioSource('backingtracks', 'silent');
                    } else {
                        // Default to latest recording if no selected backing track
                        loadLatestRecording('silent');
                    }
                })
                .catch(error => {
                    console.error('Error checking selected backing track:', error);
                    // Fallback to latest recording
                    loadLatestRecording('silent');
                });
        }

        // Select audio source (backingtracks, latest recording, or all recordings)
        function selectAudioSource(source, context = 'user') {
            const backingtracksTab = document.getElementById('tab-backingtracks');
            const latestTab = document.getElementById('tab-latest');
            const allTab = document.getElementById('tab-all');
            const backingtracksControls = document.getElementById('backingtracks-controls');
            const allControls = document.getElementById('all-recordings-controls');

            // Update tab selection
            if (source === 'backingtracks') {
                backingtracksTab.classList.add('active');
                latestTab.classList.remove('active');
                allTab.classList.remove('active');
                backingtracksControls.classList.remove('hidden');
                allControls.classList.add('hidden');

                // Clear current audio and load backing tracks
                clearAudioPlayer();
                loadBackingtracks(context);
            } else if (source === 'latest') {
                latestTab.classList.add('active');
                backingtracksTab.classList.remove('active');
                allTab.classList.remove('active');
                backingtracksControls.classList.add('hidden');
                allControls.classList.add('hidden');

                // Load latest recording
                loadLatestRecording(context);
            } else if (source === 'all') {
                allTab.classList.add('active');
                backingtracksTab.classList.remove('active');
                latestTab.classList.remove('active');
                backingtracksControls.classList.add('hidden');
                allControls.classList.remove('hidden');

                // Clear current audio and load all recordings
                clearAudioPlayer();
                loadAllRecordings(context);
            }
        }

        // Load local file
        function loadLocalFile(input) {
            const file = input.files[0];
            if (file) {
                // Check if it's an audio file
                if (!file.type.startsWith('audio/')) {
                    alert('Please select a valid audio file.');
                    return;
                }

                updatePlayerStatus(`üì§ Uploading ${file.name} to server...`);

                // Create FormData for file upload
                const formData = new FormData();
                formData.append('audio_file', file);

                // Upload file to server
                fetch('/api/upload-local-file', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('‚úÖ File uploaded successfully:', data.file_name);

                        // Load the uploaded file using the /api/backingtrack/ endpoint
                        const audioPlayer = document.getElementById('audio-player');
                        const fileInfo = document.getElementById('file-info');

                        audioPlayer.src = `/api/backingtrack/${encodeURIComponent(data.file_name)}?t=${new Date().getTime()}`;
                        showAudioPlayer();

                        // Show file information
                        const sizeInMB = (data.file_size / 1024 / 1024).toFixed(2);
                        fileInfo.innerHTML = `
                            <div style="background-color: var(--pico-color-green-50); border-left: 4px solid var(--pico-color-green); padding: 1rem; border-radius: 4px;">
                                <strong>üéµ Backingtrack Uploaded:</strong> ${data.file_name}<br>
                                <strong>Size:</strong> ${sizeInMB} MB
                            </div>
                        `;
                        fileInfo.classList.remove('hidden');

                        updatePlayerStatus(`‚úÖ Backingtrack loaded: ${data.file_name}`);

                        // Add audio event listeners
                        audioPlayer.addEventListener('loadedmetadata', function() {
                            console.log('Backingtrack metadata loaded:', data.file_name);
                            updatePlayerStatus(`‚úÖ Backingtrack ready: ${data.file_name}`);
                            clearAudioError();
                        }, { once: true });

                        audioPlayer.addEventListener('error', function(e) {
                            console.error('Backingtrack error:', e, audioPlayer.error);

                            if (context !== 'silent') {
                                const error = audioPlayer.error;
                                let errorMessage = 'Error loading backingtrack: ';
                                switch(error.code) {
                                    case error.MEDIA_ERR_ABORTED:
                                        errorMessage += 'Loading was aborted';
                                        break;
                                    case error.MEDIA_ERR_NETWORK:
                                        errorMessage += 'Network error';
                                        break;
                                    case error.MEDIA_ERR_DECODE:
                                        errorMessage += 'File format may not be supported';
                                        break;
                                    case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                        errorMessage += 'File format not supported by browser';
                                        break;
                                    default:
                                        errorMessage += 'Unknown error';
                                }
                                showAudioError(errorMessage);
                                updatePlayerStatus('Error loading backingtrack');
                            }
                        }, { once: true });
                    } else {
                        console.error('Upload failed:', data.error);
                        updatePlayerStatus(`‚ùå Upload failed: ${data.error}`);
                        showAudioError(`Upload failed: ${data.error}`);
                    }
                })
                .catch(error => {
                    console.error('Upload error:', error);
                    updatePlayerStatus('‚ùå Upload error');
                    showAudioError(`Upload error: ${error.message}`);
                });
            }
        }

        // Load latest recording from server
        function loadLatestRecording(context = 'user') {
            if (context !== 'silent') {
                updatePlayerStatus('Loading last recording...');
            }

            fetch('/api/latest-recording')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('No recording found');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.file_path) {
                        const audioPlayer = document.getElementById('audio-player');
                        const fileInfo = document.getElementById('file-info');

                        // Set audio source to the recording file with cache-busting parameter
                        const timestamp = new Date().getTime();
                        audioPlayer.src = `/api/recording/${encodeURIComponent(data.file_name)}?t=${timestamp}`;
                        showAudioPlayer();

                        // Add debugging event listeners for remote files too
                        audioPlayer.addEventListener('loadedmetadata', function() {
                            console.log('Remote file metadata loaded:', data.file_name);
                            updatePlayerStatus('Last recording loaded successfully');
                            clearAudioError();
                        }, { once: true });

                        audioPlayer.addEventListener('error', function(e) {
                            console.error('Remote file error:', e, audioPlayer.error);

                            if (context !== 'silent') {
                                const error = audioPlayer.error;
                                let errorMessage = 'Error loading recording: ';
                                switch(error.code) {
                                    case error.MEDIA_ERR_ABORTED:
                                        errorMessage += 'Loading was aborted';
                                        break;
                                    case error.MEDIA_ERR_NETWORK:
                                        errorMessage += 'Network error';
                                        break;
                                    case error.MEDIA_ERR_DECODE:
                                        errorMessage += 'File format may not be supported';
                                        break;
                                    case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                        errorMessage += 'File format not supported by browser';
                                        break;
                                    default:
                                        errorMessage += 'Unknown error';
                                }
                                showAudioError(errorMessage);
                                updatePlayerStatus('Error loading recording');
                            }
                        }, { once: true });

                        // Show file information
                        const sizeInMB = data.file_size ? (data.file_size / 1024 / 1024).toFixed(2) + ' MB' : 'Unknown';

                        fileInfo.innerHTML = `
                            <strong>Recording:</strong> ${data.file_name}<br>
                            <strong>Size:</strong> ${sizeInMB}<br>
                            <strong>Created:</strong> ${new Date(data.created_at).toLocaleString()}
                        `;
                        fileInfo.classList.remove('hidden');
                    } else {
                        throw new Error(data.error || 'Failed to load recording');
                    }
                })
                .catch(error => {
                    console.error('Failed to load latest recording:', error);
                    clearAudioPlayer();
                    updatePlayerStatus('No recordings available yet');
                });
        }

        // Update player status message
        function updatePlayerStatus(message) {
            document.getElementById('player-status').textContent = message;
        }

        // Show audio player
        function showAudioPlayer() {
            const player = document.getElementById('audio-player');
            const status = document.getElementById('player-status');

            player.classList.remove('hidden');
            status.classList.add('hidden');
        }

        // Clear audio player
        function clearAudioPlayer() {
            const player = document.getElementById('audio-player');
            const status = document.getElementById('player-status');
            const fileInfo = document.getElementById('file-info');

            // Clean up any existing object URL before clearing the player
            if (window.currentAudioURL) {
                URL.revokeObjectURL(window.currentAudioURL);
                window.currentAudioURL = null;
            }

            player.src = '';
            player.classList.add('hidden');
            status.classList.remove('hidden');
            fileInfo.classList.add('hidden');
            clearAudioError();

            // Note: We keep the file preference saved on the server when switching sources
            // This allows users to return to their previously selected local file
        }

        // Show audio error message
        function showAudioError(message) {
            const errorDiv = document.getElementById('audio-error');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        // Clear audio error message
        function clearAudioError() {
            const errorDiv = document.getElementById('audio-error');
            errorDiv.textContent = '';
            errorDiv.classList.add('hidden');
        }

        // Format duration in seconds to MM:SS
        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // ===== ALL RECORDINGS FUNCTIONS =====

        // Load all recordings from server
        function loadAllRecordings(context = 'user') {
            if (context !== 'silent') {
                document.getElementById('recordings-status').textContent = 'Loading recordings...';
                document.getElementById('recordings-list').classList.add('hidden');
                document.getElementById('recordings-pagination').classList.add('hidden');
            }

            fetch('/api/files')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load recordings');
                    }
                    return response.json();
                })
                .then(data => {
                    allRecordings = data.files || [];
                    console.log(`Loaded ${allRecordings.length} recordings`);

                    // Apply current search and sort
                    filterAndSortRecordings();
                    renderRecordingsList();

                    // Setup event listeners for search and sort
                    setupRecordingsEventListeners();
                })
                .catch(error => {
                    console.error('Failed to load recordings:', error);
                    document.getElementById('recordings-status').textContent = 'Error loading recordings';
                });
        }

        // Setup event listeners for search and sort
        function setupRecordingsEventListeners() {
            const searchInput = document.getElementById('recordings-search');
            const sortSelect = document.getElementById('recordings-sort');

            // Remove existing event listeners to avoid duplicates
            searchInput.removeEventListener('input', handleRecordingsSearch);
            sortSelect.removeEventListener('change', handleRecordingsSort);

            // Add new event listeners
            searchInput.addEventListener('input', handleRecordingsSearch);
            sortSelect.addEventListener('change', handleRecordingsSort);
        }

        // Handle search input
        function handleRecordingsSearch(event) {
            searchQuery = event.target.value.toLowerCase();
            currentPage = 1; // Reset to first page
            filterAndSortRecordings();
            renderRecordingsList();
        }

        // Handle sort change
        function handleRecordingsSort(event) {
            currentSort = event.target.value;
            currentPage = 1; // Reset to first page
            filterAndSortRecordings();
            renderRecordingsList();
        }

        // Filter and sort recordings based on search and sort criteria
        function filterAndSortRecordings() {
            // Filter by search query
            filteredRecordings = allRecordings.filter(recording => {
                return recording.name.toLowerCase().includes(searchQuery);
            });

            // Sort the filtered results
            filteredRecordings.sort((a, b) => {
                switch (currentSort) {
                    case 'date_asc':
                        return new Date(a.mod_time) - new Date(b.mod_time);
                    case 'date_desc':
                        return new Date(b.mod_time) - new Date(a.mod_time);
                    case 'name_asc':
                        return a.name.localeCompare(b.name);
                    case 'name_desc':
                        return b.name.localeCompare(a.name);
                    default:
                        return new Date(b.mod_time) - new Date(a.mod_time);
                }
            });
        }

        // Render recordings list with pagination
        function renderRecordingsList() {
            const statusElement = document.getElementById('recordings-status');
            const listElement = document.getElementById('recordings-list');
            const paginationElement = document.getElementById('recordings-pagination');

            if (filteredRecordings.length === 0) {
                statusElement.textContent = searchQuery ? `No recordings found matching "${searchQuery}"` : 'No recordings available';
                listElement.classList.add('hidden');
                paginationElement.classList.add('hidden');
                return;
            }

            // Hide status and show list
            statusElement.classList.add('hidden');
            listElement.classList.remove('hidden');
            paginationElement.classList.remove('hidden');

            // Calculate pagination
            const totalPages = Math.ceil(filteredRecordings.length / ITEMS_PER_PAGE);
            const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
            const endIndex = startIndex + ITEMS_PER_PAGE;
            const pageRecordings = filteredRecordings.slice(startIndex, endIndex);

            // Render recordings
            listElement.innerHTML = '';
            pageRecordings.forEach(recording => {
                const recordingElement = createRecordingElement(recording);
                listElement.appendChild(recordingElement);
            });

            // Update pagination
            updateRecordingsPagination(totalPages);
        }

        // Create HTML element for a recording
        function createRecordingElement(recording) {
            const div = document.createElement('div');
            div.className = 'recording-item';

            // Format date for display
            const date = new Date(recording.mod_time);
            const formattedDate = date.toLocaleDateString('en-US', {
                month: 'numeric',
                day: 'numeric',
                year: '2-digit'
            });

            div.innerHTML = `
                <span class="recording-name">üìÅ ${recording.name}</span>
                <span class="recording-size">${recording.size_human}</span>
                <span class="recording-date">${formattedDate}</span>
                <button class="recording-btn play" onclick="playRecording('${recording.name}')" title="Play">
                    ‚ñ∂Ô∏è
                </button>
                <button class="recording-btn backing" onclick="setAsBackingTrack('${recording.name}')" title="Set as backing track">
                    üéµ
                </button>
                <button class="recording-btn download" onclick="downloadRecording('${recording.name}')" title="Download">
                    üì•
                </button>
            `;

            return div;
        }

        // Update pagination controls
        function updateRecordingsPagination(totalPages) {
            const infoText = document.getElementById('pagination-info-text');
            const totalText = document.getElementById('pagination-total-text');
            const prevBtn = document.getElementById('pagination-prev');
            const nextBtn = document.getElementById('pagination-next');

            infoText.textContent = `Page ${currentPage} of ${totalPages}`;
            totalText.textContent = `(${filteredRecordings.length} recording${filteredRecordings.length !== 1 ? 's' : ''})`;

            prevBtn.disabled = currentPage <= 1;
            nextBtn.disabled = currentPage >= totalPages;
        }

        // Navigate to previous page
        function previousRecordingsPage() {
            if (currentPage > 1) {
                currentPage--;
                renderRecordingsList();
            }
        }

        // Navigate to next page
        function nextRecordingsPage() {
            const totalPages = Math.ceil(filteredRecordings.length / ITEMS_PER_PAGE);
            if (currentPage < totalPages) {
                currentPage++;
                renderRecordingsList();
            }
        }

        // Play a recording in the main audio player
        function playRecording(filename) {
            const audioPlayer = document.getElementById('audio-player');

            // Set audio source with cache-busting parameter
            const timestamp = new Date().getTime();
            audioPlayer.src = `/api/files/stream/${encodeURIComponent(filename)}?t=${timestamp}`;

            showAudioPlayer();
            updatePlayerStatus(`Playing: ${filename}`);

            // Add event listeners for this specific load
            audioPlayer.addEventListener('loadedmetadata', function() {
                console.log('Recording metadata loaded:', filename);
                updatePlayerStatus(`‚úÖ Playing: ${filename}`);
                clearAudioError();

                // Automatically start playback
                audioPlayer.play().then(() => {
                    console.log('Playback started successfully for:', filename);
                }).catch(error => {
                    console.warn('Autoplay blocked by browser:', error);
                    updatePlayerStatus(`‚úÖ Ready: ${filename} - Click ‚ñ∂Ô∏è to play`);
                });
            }, { once: true });

            audioPlayer.addEventListener('error', function(e) {
                console.error('Recording playback error:', e, audioPlayer.error);
                const error = audioPlayer.error;
                let errorMessage = 'Error playing recording: ';
                switch(error.code) {
                    case error.MEDIA_ERR_ABORTED:
                        errorMessage += 'Loading was aborted';
                        break;
                    case error.MEDIA_ERR_NETWORK:
                        errorMessage += 'Network error';
                        break;
                    case error.MEDIA_ERR_DECODE:
                        errorMessage += 'File format may not be supported';
                        break;
                    case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMessage += 'File format not supported by browser';
                        break;
                    default:
                        errorMessage += 'Unknown error';
                }
                showAudioError(errorMessage);
                updatePlayerStatus('Error playing recording');
            }, { once: true });

            // Update file info
            const recording = allRecordings.find(r => r.name === filename);
            if (recording) {
                const fileInfo = document.getElementById('file-info');
                fileInfo.innerHTML = `
                    <strong>Playing:</strong> ${filename}<br>
                    <strong>Size:</strong> ${recording.size_human}<br>
                    <strong>Created:</strong> ${new Date(recording.mod_time).toLocaleString()}
                `;
                fileInfo.classList.remove('hidden');
            }
        }

        // Set recording as backing track
        function setAsBackingTrack(filename) {
            convertToBackingtrack(filename);
        }

        // Download a recording
        function downloadRecording(filename) {
            const recording = allRecordings.find(r => r.name === filename);
            if (recording) {
                // Create temporary link and click it to trigger download
                const link = document.createElement('a');
                link.href = recording.download_url;
                link.download = filename;
                link.click();

                console.log('Download started for:', filename);
            }
        }

        // ===== END ALL RECORDINGS FUNCTIONS =====

        // ===== END AUDIO PLAYER FUNCTIONS =====


        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }

            // Clean up any remaining audio object URLs
            if (window.currentAudioURL) {
                URL.revokeObjectURL(window.currentAudioURL);
                window.currentAudioURL = null;
            }

            // Unlock profile when leaving the page
            fetch('/config/unlock', {
                method: 'POST',
                keepalive: true
            }).catch(() => {
                // Ignore errors during page unload
            });
        });

        // ===== BACKING TRACKS FUNCTIONS =====

        // Global variables for backing tracks
        let currentBackingtracks = [];
        let filteredBackingtracks = [];
        let backingtracksPaginationInfo = { currentPage: 1, totalPages: 1, itemsPerPage: 10 };

        // Load backing tracks from API
        function loadBackingtracks(context = 'user') {
            const statusDiv = document.getElementById('backingtracks-status');
            const listDiv = document.getElementById('backingtracks-list');
            const paginationDiv = document.getElementById('backingtracks-pagination');

            if (context !== 'silent') {
                statusDiv.innerHTML = 'Loading backing tracks...';
                statusDiv.classList.remove('hidden');
            }

            fetch('/api/backingtracks')
                .then(response => response.json())
                .then(data => {
                    if (data.backingtracks && data.backingtracks.length > 0) {
                        currentBackingtracks = data.backingtracks;
                        filteredBackingtracks = [...currentBackingtracks];

                        // Try to load the selected backing track
                        const selectedBt = currentBackingtracks.find(bt => bt.is_selected);
                        if (selectedBt && context !== 'silent') {
                            loadBackingtrackAudio(selectedBt);
                        }

                        displayBackingtracks();
                        statusDiv.classList.add('hidden');
                        listDiv.classList.remove('hidden');
                        paginationDiv.classList.remove('hidden');
                    } else {
                        statusDiv.innerHTML = `
                            <div style="text-align: center; color: var(--pico-muted-color); padding: 2rem;">
                                <div style="font-size: 3rem;">üéµ</div>
                                <h4>No Backing Tracks</h4>
                                <p>You haven't added any backing tracks yet. Upload an audio file below or convert a recording to a backing track.</p>
                            </div>
                        `;
                        statusDiv.classList.remove('hidden');
                        listDiv.classList.add('hidden');
                        paginationDiv.classList.add('hidden');
                    }
                })
                .catch(error => {
                    console.error('Error loading backing tracks:', error);
                    statusDiv.innerHTML = `
                        <div style="color: var(--pico-color-danger); text-align: center; padding: 2rem;">
                            ‚ùå Error loading backing tracks: ${error.message || error}
                        </div>
                    `;
                });
        }

        // Display backing tracks with pagination
        function displayBackingtracks() {
            const listDiv = document.getElementById('backingtracks-list');
            const startIdx = (backingtracksPaginationInfo.currentPage - 1) * backingtracksPaginationInfo.itemsPerPage;
            const endIdx = startIdx + backingtracksPaginationInfo.itemsPerPage;
            const pageItems = filteredBackingtracks.slice(startIdx, endIdx);

            listDiv.innerHTML = pageItems.map(bt => createBackingtrackItemHTML(bt)).join('');
            updateBackingtracksPagination();
        }

        // Create HTML for a backing track item
        function createBackingtrackItemHTML(bt) {
            const selectedBadge = bt.is_selected ? ' ‚≠ê' : '';

            // Format date for display (matching recordings format)
            const date = new Date(bt.mod_time);
            const formattedDate = date.toLocaleDateString('en-US', {
                month: 'numeric',
                day: 'numeric',
                year: '2-digit'
            });

            return `
                <div class="recording-item ${bt.is_selected ? 'selected-backingtrack' : ''}">
                    <span class="recording-name">üéµ ${bt.name}${selectedBadge}</span>
                    <span class="recording-size">üìä ${bt.size_human}</span>
                    <span class="recording-date">üïí ${formattedDate}</span>
                    <span class="recording-format">üéº ${bt.extension.toUpperCase()}</span>
                    <button class="recording-btn play" onclick="loadBackingtrackAudio(${JSON.stringify(bt).replace(/"/g, '&quot;')})" title="Play">
                        ‚ñ∂Ô∏è
                    </button>
                    <button class="recording-btn download" onclick="downloadBackingtrack('${bt.name}')" title="Download">
                        üì•
                    </button>
                </div>
            `;
        }

        // Load backing track audio
        function loadBackingtrackAudio(bt) {
            const audioPlayer = document.getElementById('audio-player');
            const fileInfoDiv = document.getElementById('file-info');

            audioPlayer.src = bt.stream_url + '?t=' + new Date().getTime();
            showAudioPlayer();

            updatePlayerStatus(`üéµ Loading backing track: ${bt.name}`);
            fileInfoDiv.innerHTML = `
                <div style="background-color: var(--pico-color-blue-50); border-left: 4px solid var(--pico-color-blue); padding: 1rem; border-radius: 4px;">
                    <strong>üéµ Backing Track:</strong> ${bt.name}<br>
                    <em>Size: ${bt.size_human} ‚Ä¢ Format: ${bt.extension.toUpperCase()}</em>
                    <br><span style="color: var(--pico-color-yellow-600);">‚≠ê Now set as current backing track</span>
                </div>
            `;
            fileInfoDiv.classList.remove('hidden');

            // Auto-select this backing track (silent)
            if (!bt.is_selected) {
                selectBackingtrack(bt.name, true); // true = silent mode
            }

            // Add audio event listeners
            audioPlayer.addEventListener('loadedmetadata', function() {
                updatePlayerStatus(`‚úÖ Backing track ready: ${bt.name}`);
                clearAudioError();
            }, { once: true });

            audioPlayer.addEventListener('error', function(e) {
                console.error('Backing track error:', e);
                updatePlayerStatus('‚ùå Error loading backing track');
                showAudioError('Error loading backing track - file may be corrupted or inaccessible');
            }, { once: true });
        }

        // Select backing track
        function selectBackingtrack(name, silent = false) {
            fetch('/api/backingtracks/select', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: name
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    if (!silent) {
                        updatePlayerStatus(`üåü Selected backing track: ${name}`);
                    }
                    // Reload backing tracks to update UI
                    loadBackingtracks('silent');
                } else {
                    if (!silent) {
                        showAudioError(`Error selecting backing track: ${data.error}`);
                    }
                }
            })
            .catch(error => {
                console.error('Error selecting backing track:', error);
                if (!silent) {
                    showAudioError(`Error selecting backing track: ${error.message}`);
                }
            });
        }

        // Download backing track
        function downloadBackingtrack(name) {
            const downloadUrl = `/api/backingtracks/download/${encodeURIComponent(name)}`;

            // Create temporary link and click it
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = name;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            updatePlayerStatus(`üì• Downloading: ${name}`);
        }

        // Convert recording to backing track
        function convertToBackingtrack(recordingName) {
            if (!confirm(`Convert "${recordingName}" to a backing track?\n\nThis will move the file to your backing tracks directory and set it as the selected backing track.`)) {
                return;
            }

            fetch('/api/backingtracks/convert', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    recording_name: recordingName
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updatePlayerStatus(`‚úÖ ${data.message}`);
                    // Refresh recordings list and backing tracks if currently viewing
                    if (document.getElementById('tab-all').classList.contains('active')) {
                        loadAllRecordings('silent');
                    }
                    if (document.getElementById('tab-backingtracks').classList.contains('active')) {
                        loadBackingtracks('silent');
                    }
                } else {
                    showAudioError(`Error converting to backing track: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error converting to backing track:', error);
                showAudioError(`Error converting to backing track: ${error.message}`);
            });
        }

        // Backing tracks search and sort
        function setupBackingtracksControls() {
            const searchInput = document.getElementById('backingtracks-search');
            const sortSelect = document.getElementById('backingtracks-sort');

            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    const searchTerm = e.target.value.toLowerCase();
                    filteredBackingtracks = currentBackingtracks.filter(bt =>
                        bt.name.toLowerCase().includes(searchTerm)
                    );
                    backingtracksPaginationInfo.currentPage = 1;
                    displayBackingtracks();
                });
            }

            if (sortSelect) {
                sortSelect.addEventListener('change', function(e) {
                    const sortBy = e.target.value;
                    sortBackingtracks(sortBy);
                    backingtracksPaginationInfo.currentPage = 1;
                    displayBackingtracks();
                });
            }
        }

        // Sort backing tracks (with current backing track always first)
        function sortBackingtracks(sortBy) {
            filteredBackingtracks.sort((a, b) => {
                // Always put the selected backing track first
                if (a.is_selected && !b.is_selected) return -1;
                if (!a.is_selected && b.is_selected) return 1;

                // Then apply the requested sort
                switch (sortBy) {
                    case 'date_desc':
                        return new Date(b.mod_time) - new Date(a.mod_time);
                    case 'date_asc':
                        return new Date(a.mod_time) - new Date(b.mod_time);
                    case 'name_asc':
                        return a.name.localeCompare(b.name);
                    case 'name_desc':
                        return b.name.localeCompare(a.name);
                    default:
                        return 0;
                }
            });
        }

        // Update backing tracks pagination
        function updateBackingtracksPagination() {
            const totalItems = filteredBackingtracks.length;
            const totalPages = Math.ceil(totalItems / backingtracksPaginationInfo.itemsPerPage);

            backingtracksPaginationInfo.totalPages = totalPages;

            const paginationInfo = document.getElementById('backingtracks-pagination-info');
            const totalInfo = document.getElementById('backingtracks-total-info');
            const prevBtn = document.getElementById('backingtracks-prev');
            const nextBtn = document.getElementById('backingtracks-next');

            if (paginationInfo) {
                paginationInfo.textContent = `Page ${backingtracksPaginationInfo.currentPage} of ${totalPages}`;
            }

            if (totalInfo) {
                totalInfo.textContent = `(${totalItems} backing track${totalItems !== 1 ? 's' : ''})`;
            }

            if (prevBtn) {
                prevBtn.disabled = backingtracksPaginationInfo.currentPage <= 1;
            }

            if (nextBtn) {
                nextBtn.disabled = backingtracksPaginationInfo.currentPage >= totalPages;
            }
        }

        // Pagination functions
        function nextBackingtracksPage() {
            if (backingtracksPaginationInfo.currentPage < backingtracksPaginationInfo.totalPages) {
                backingtracksPaginationInfo.currentPage++;
                displayBackingtracks();
            }
        }

        function previousBackingtracksPage() {
            if (backingtracksPaginationInfo.currentPage > 1) {
                backingtracksPaginationInfo.currentPage--;
                displayBackingtracks();
            }
        }

        // Initialize backing tracks controls when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setupBackingtracksControls();
        });
    </script>
</body>
</html>
